/*
 * thread_manager.c
 *
 *  Created on: Apr 4, 2013
 *      Author: kulis
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

#define NUM_TASKS 5

//milliseconds
#define RESOLUTION 1000

pthread_mutex_t bogus_lock;

pthread_cond_t motor, gyro, gps, sonic, runtime, running_task_complete;
pthread_attr_t attr;

typedef struct task {

	int id;
	int phase;
	int period;
	int rd;
	int et;
	int priority;

};

struct task motor_control, gyro_read, sonic_read, gps_read, runtime_control;
pthread_cond_t* waiting_tasks[NUM_TASKS];
int wt_size = 0;

void motor_control_task(void *args){}
void gyro_task(void *args){}
void gps_task(void *args){}
void sonic_task(void *args){}
void runtime_task(void *args){}

void release_agent(void *args){

	int pos = 0;
	while(1){

		pthread_cond_wait(&running_task_complete, &bogus_lock);

		if(wt_size){
			pthread_cond_signal(waiting_tasks[pos]);
			pos++;
			wt_size--;
		}
		else pos = 0;
	}
}

void scheduler(void *args){

	int mc_tick = 0, gr_tick = 0, sr_tick = 0, gpsr_tick = 0;
	int first_run = 1;
	int p = 0;
	int new_task = 0;

	while(1){

		//todo write release rules (scheduling policy)

		if(new_task) pthread_cond_signal(&running_task_complete);
		new_task = 0;
		usleep(RESOLUTION);

		//note: have simple release mechanism in previous version
		//that uses a lot of the above variables that may not be used
		//when creating a policy
	}
}

int main(int argc, char** argv){

	pthread_attr_int(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	pthread_mutex_init(&bogus_lock);

	//set characteristics for motor control
	motor_control.id = 1;
	motor_control.et = 200 * RESOLUTION;
	motor_control.period = 350 * RESOLUTION;
	motor_control.phase = 0;
	motor_control.priority = 3;

	//set characteristics for gyro read
	gyro_read.id = 2;
	gyro_read.et = 50 * RESOLUTION;
	gyro_read.period = 250 * RESOLUTION;
	gyro_read.phase = 0;
	gyro_read.priority = 4;

	//set characteristics for sonic read
	sonic_read.id = 3;
	sonic_read.et = 50 * RESOLUTION;
	sonic_read.period = 100 * RESOLUTION;
	sonic_read.phase = 0;
	sonic_read.priority = 2;

	//set characteristics for gps_read
	gps_read.id = 4;
	gps_read.et = 100 * RESOLUTION;
	gps_read.period = 1000 * RESOLUTION;
	gps_read.phase = 0;
	gps_read.priority = 5;

	//set characteristics for the run time
	runtime_control.id = 5;
	runtime_control.et = 30 * RESOLUTION;
	runtime_control.period = 75 * RESOLUTION;
	runtime_control.phase = 0;
	runtime_control.priority = 1;

	pthread_t  mc_job, gyro_job, sonic_job, gps_job, rt_job;
	pthread_create(&mc_job, &attr, (void *) motor_control_task, (void *) &motor_control);
	pthread_create(&gyro_job, &attr, (void *) gyro_task, (void *) &gyro_read);
	pthread_create(&sonic_job, &attr, (void *) sonic_task, (void *) &sonic_read);
	pthread_create(&gps_job, &attr, (void *) gps_task, (void *) &gps_read);
	pthread_create(&rt_job, &attr, (void *) runtime_task, (void *) &rt_job);

	while(1);

	//will never happen
	pthread_exit(NULL);

	return EXIT_SUCCESS;
}
