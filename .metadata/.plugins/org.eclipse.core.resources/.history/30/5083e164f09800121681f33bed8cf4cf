/*
 * graph.c
 *
 *  Created on: Mar 29, 2013
 *      Author: kulis
 */

#include "graph.h"

int _g_stack_ref = 0;

int _g_heading = NORTH;
int get_sr(){ return _g_stack_ref; }
int get_hd(){ return _g_heading; }

void _g_push(int east, int south, int west, int north){

	int gsr = _g_stack_ref;

	Graph[gsr].possible_directions[EAST] = east;
	Graph[gsr].possible_directions[SOUTH] = south;
	Graph[gsr].possible_directions[WEST] = west;
	Graph[gsr].possible_directions[NORTH] = north;

	memset(Graph[gsr].visited_locations, 0, 4);

	_g_stack_ref = (_g_stack_ref + 1) % _G_STACK_SIZE;

}


/*
 * Recursively finds the next right turn according to heading
 */
int _get_right(int dir){

	//impossible to happen? just to make sure not an infinite loop
	int pass = 0;

	int gsr = _g_stack_ref;

	//skip to next possible direction
	while(!Graph[gsr].possible_directions[++dir] && !pass){

		//check on infinite loop
		if(dir == _g_heading - 1) pass = !pass;

	}

	//dead end
	if(dir == _g_heading) return _g_heading;

	if(Graph[gsr].visited_directions[dir]) _get_right(dir);

	return dir;

}


void _g_pop(){ _g_stack_ref--; }

int get_next_direction(int east, int south, int west, int north){

	//sanity check
	if(north > 1 || east > 1 || west > 1 || south > 1 ||
	   north < 0 || east < 0 || west < 0 || south < 0) return -1;

	//new node


	if(!_g_backtracking) _g_push(east, south, west, north);

	else _g_pop();

	_g_heading = _get_right(_g_heading);

	return _g_heading;

}
