/*
 * pid.c
 *
 *  Created on: Mar 17, 2013
 *      Author: kulis
 */

#include "pid.h"

//reference structs
PID* _pids;
int _pids_recs_len = 0;
struct timeval _time;

//timing
unsigned long  _prev_time = 0;

int _diff_time = 0;
int _sec_rollover = 0;

//secret computation vals
double _error = 0.0, _diff_input = 0.0;

//hold vals
double _i_val = 0.0, _last_input = 0.0;

/*
 * Builds an array of PID structs with values set to 0 or null
 */
PID* init(int quantity){

	if(!quantity || (_pids = (PID*) malloc(sizeof(PID) * quantity)) == NULL){
		return NULL;
	}

	int i = 0;
	for(; i < quantity; i++){
		PID p;
		_pids[i] = p;
	}

	_pids_recs_len = quantity;

	return _pids;
}

int run(PID *p){


	//is it meant to run?
	if(p->is_paused) return 0;

	double ki_s, kd_s;
	ki_s = p->ki * p->interval / 1000;
	kd_s = p->kd / p->interval / 1000;

		//get the time
	if(gettimeofday(&_time, NULL)){
		return 0;
	}

	if(_time.tv_usec < _prev_time) _sec_rollover = 1000000;
	else _sec_rollover = 0;

	//find time interval
	_diff_time = _prev_time != 0 ? _sec_rollover + _time.tv_usec - _prev_time : _time.tv_usec;
	_diff_time /= 1000;

	//verify enough time has passed
	if(_diff_time < p->interval) return 0;

	//find error
	_error = p->goal - p->input;

	//computer i partial
	_i_val += (ki_s * _error);

	//check for bounds
	_i_val = _i_val > p->max ? p->max : _i_val < p->min ? p->min : _i_val;

	//get the diff in input
	_diff_input = p->input - _last_input;

	//get pid
	p->output = (p->kp * _error) + _i_val - (kd_s * _diff_input);

	//check again for bounds
	p->output = p->output > p->max ? p->max : p->output < p->min ? p->min : p->output;

	//update loop vals
	_last_input = p->input;
	_prev_time = _time.tv_usec;

	return 1;
}
