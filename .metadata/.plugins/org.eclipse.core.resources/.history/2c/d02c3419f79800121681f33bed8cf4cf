/*
 * graph.c
 *
 *  Created on: Mar 29, 2013
 *      Author: kulis
 */

#include "graph.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int _g_stack_ref = -1;
int _g_backtracking = 0;
int _g_heading = NORTH;

//for testing stuff only
int get_sr(){ return _g_stack_ref; }
int get_hd(){ return _g_heading; }

/*
 * "private" pushes a new node
 */
void _g_push(int east, int south, int west, int north){

	//update stack pointer
	_g_stack_ref = (_g_stack_ref + 1) % _G_STACK_SIZE;

	//shorthand
	int gsr = _g_stack_ref;

	//set the possibles
	Graph[gsr].possible_directions[EAST] = east;
	Graph[gsr].possible_directions[SOUTH] = south;
	Graph[gsr].possible_directions[WEST] = west;
	Graph[gsr].possible_directions[NORTH] = north;

	//set the visited
	memset(&Graph[gsr].visited_directions, 0, 4);

	//mark where we came from
	Graph[gsr].visited_directions[(_g_heading + 2) % 4] = 1;



}


/*
 * "private"
 * Recursively finds the next turn according to heading.
 * Idea is to counter clockwise find the next turn, so pass it +1 of
 * your heading
 */
int _get_left(int dir){


	//impossible to happen? just to make sure not an infinite loop
	int pass = 0;

	//shorthand
	int gsr = _g_stack_ref;

	//skip to next possible direction
	while(!Graph[gsr].possible_directions[dir] && !pass){

		if(--dir == -1) dir = 4;

		//check on infinite loop
		if(dir == (_g_heading + 1) % 4) pass = !pass;

	}

	//dead end
	if(dir == (_g_heading + 2) % 4){
		_g_backtracking = 1;
		_g_heading = dir;
		return _g_heading;
	}

	//hmm. stopping conditions not met, recursively dig
	if(Graph[gsr].visited_directions[dir]) _get_left(dir);

	//clear out possible backtrack
	_g_backtracking = 0;

	return dir;

}

/*
 * private - moves pointer back up
 */
void _g_pop(){ _g_stack_ref--; }

/*
 * Call this function with known directional booleans. Returns
 * the direction you should take
 */
int get_next_direction(int east, int south, int west, int north){

	//sanity check
	if(north > 1 || east > 1 || west > 1 || south > 1 ||
	   north < 0 || east < 0 || west < 0 || south < 0) return -1;

	//new node


	if(!_g_backtracking) _g_push(east, south, west, north);

	else _g_pop();

	_g_heading = _get_left((_g_heading + 1) % 4);

	return _g_heading;


}
