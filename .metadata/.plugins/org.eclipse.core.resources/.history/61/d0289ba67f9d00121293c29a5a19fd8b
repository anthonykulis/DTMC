/*
 * tt.c
 *
 *  Created on: Apr 4, 2013
 *      Author: kulis
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t t1_lock;
pthread_cond_t t1_cond;

struct thread_data {

	int id;
	int phase;
	int period;
	int relative_deadline;
	int execution_time;
	int complete;

};

struct thread_data t;


void* p1_task(void *thread_arg){

	while(1){
		pthread_cond_wait(&t1_cond, &t1_lock);
		fprintf(stdout, "Doing task\n");
		pthread_mutex_lock(&t1_lock);
		fprintf(stdout, "Got lock\n");
		t.complete = 0;
		fprintf(stdout, "Sleeping\n");
		usleep(t.execution_time);
		fprintf(stdout, "Wake\n");
		t.complete = 1;
		pthread_mutex_unlock(&t1_lock);
		fprintf(stdout, "Done\n");
		//pthread_yield();

	}

	pthread_exit(NULL);
	return NULL;
}

void* sched(void *thread_arg){

	int i = 0;
	for(; i < 10; i++){
		fprintf(stdout, "Signaling %d\n", i);
		pthread_cond_signal(&t1_cond);
		while(!t.complete){
			usleep(1);
		}

	}
	pthread_exit(NULL);
	return NULL;
}

int main(){

	pthread_mutex_init(&t1_lock);
	t.execution_time = 1000;
	t.id = 1;
	t.period = 100;
	t.phase = 0;
	t.relative_deadline = 200000;
	pthread_t t1, sch;
	int rc = pthread_create(&t1, NULL, p1_task, (void *) &t);
	rc = pthread_create(&sch, NULL, sched, (void *) &t);

    void* status;
//	/pthread_join(rc, &status);
	pthread_exit(NULL);
}
