/*
 * graph.c
 *
 *  Created on: Mar 29, 2013
 *      Author: kulis
 */

#include "graph.h"

int _g_stack_ref = 0;

int _g_heading = NORTH;
int get_sr(){ return _g_stack_ref; }
int get_hd(){ return _g_heading; }

void _g_push(int north, int east, int west, int south){

	int gsr = _g_stack_ref;

	Graph[gsr].north = north;
	Graph[gsr].south = south;
	Graph[gsr].east = east;
	Graph[gsr].west = west;
	Graph[gsr].north_visited = 0;
	Graph[gsr].south_visited = 0;
	Graph[gsr].east_visited = 0;
	Graph[gsr].west_visited = 0;

	_g_stack_ref = (_g_stack_ref + 1) % _G_STACK_SIZE;

}

void _g_pop(){ _g_stack_ref--; }

int get_next_direction(int east, int north, int west, int south){

	//sanity check
	if(north > 1 || east > 1 || west > 1 || south > 1 ||
	   north < 0 || east < 0 || west < 0 || south < 0) return -1;

	//new node
	if(_g_heading != SOUTH){

		_g_push(north, east, west, south);
		_g_node *g = &Graph[_g_stack_ref];

		//default behavior (go right)
		if(east){
			_g_heading = EAST;
			g->east_visited = 1;
		}

		//secondary behavior
		else if(north){
			_g_heading = NORTH;
			g->north_visited = 1;
		}

		//final behavior w/o backtracking
		else if(west){
			_g_heading = WEST;
			g->west_visited = 1;
		}

		//this should only happen in dead end, causing a back track to occur
		else if(south){
			_g_heading = SOUTH;
			g->south_visited = 1;
			_g_pop();
		}

		//sanity check
		else return -1;

		return _g_heading;
	}

	//backtracking
	else {

		_g_node *g = &Graph[_g_stack_ref];

		//probably should write a fancy function for all of this
		if(_g_heading == EAST){

			//back tracking this way only gives up norht and west to go
			if(!g->north_visited){
				_g_heading = NORTH;
				g->north_visited = 1;
			}
			else if(!g->west_visited){
				_g_heading = WEST;
				g->west_visited = 1;
			}
			else return -1;

		}

		else if(_g_heading == NORTH){

			if(!g->west_visited){
				_g_heading = WEST;
				g->west_visited = 1;
			}

			else return -1;

		}

		return _g_heading;
	}


}
