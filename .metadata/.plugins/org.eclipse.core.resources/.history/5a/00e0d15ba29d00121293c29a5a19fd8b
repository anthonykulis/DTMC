/*
 * thread_manager.c
 *
 *  Created on: Apr 4, 2013
 *      Author: kulis
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>

#define NUM_TASKS 5

//jic we want it
enum { MOTORCONTROLLER, GYRO, GPS, RUNTIME_LOGIC };

// resolution is number of uS to multiply by
#define RESOLUTION 1000

pthread_mutex_t bogus_lock;

pthread_cond_t motor, gyro, gps, sonic, runtime, running_task_complete;
pthread_attr_t attr;

typedef struct {
	int id , phase, period, rd, et, priority;
} TASK;

TASK motor_control, gyro_read, sonic_read, gps_read, runtime_control;
pthread_cond_t* waiting_tasks[NUM_TASKS];
int wt_size = 0;


//our tasks
void motor_control_task(void *args){

	while(1){

		pthread_cond_wait(&motor, &bogus_lock);

		//instead of sleep, do motor control here
		usleep(motor_control.et);

		pthread_cond_signal(&running_task_complete);

	}
}

void gyro_task(void *args){

	while(1){

		pthread_cond_wait(&gyro, &bogus_lock);

		//instead of sleep, do gyro read here
		usleep(gyro_read.et);

		pthread_cond_signal(&running_task_complete);

	}
}

void gps_task(void *args){

	while(1){

		pthread_cond_wait(&gps, &bogus_lock);

		//instead of sleep, do gps read here
		usleep(gps_read.et);

		pthread_cond_signal(&running_task_complete);

	}
}


void sonic_task(void *args){

	while(1){

		pthread_cond_wait(&sonic, &bogus_lock);

		//instead of sleep, do sonic read here
		usleep(sonic_read.et);

		pthread_cond_signal(&running_task_complete);

	}

}
void runtime_task(void *args){

	while(1){

		pthread_cond_wait(&runtime, &bogus_lock);

		//instead of sleep, do runtime control here
		usleep(runtime_control.et);

		pthread_cond_signal(&running_task_complete);

	}

}


//when a task completes, it signals via running_task_complete, in which this task then signals the next job to start
void release_agent(void *args){

	int pos = 0;
	while(1){

		pthread_cond_wait(&running_task_complete, &bogus_lock);

		if(wt_size){
			pthread_cond_signal(waiting_tasks[pos]);
			pos++;
			wt_size--;
		}
		else pos = 0;
	}
}

//how jobs are scheduled to be run
void scheduler(void *args){

	int mc_tick = 0, gr_tick = 0, sr_tick = 0, gpsr_tick = 0;
	int first_run = 1;
	int p = 0;
	int new_task = 0;

	//todo: remove
	struct timeval s, e;
	int start, end;

	while(1){

		gettimeofday(&s, NULL);
		start = s.tv_usec;

		printf("Ticking\n");
		//todo write release rules (scheduling policy)

		if(new_task) pthread_cond_signal(&running_task_complete);
		new_task = 0;

		//sleep for a second for now
		usleep(RESOLUTION * RESOLUTION);

		//note: have simple release mechanism in previous version
		//that uses a lot of the above variables that may not be used
		//when creating a policy

		gettimeofday(&e, NULL);
		end = e.tv_usec;

		//todo: remove
		printf("Slept for %d -- actual %d - %d = %d\n", RESOLUTION * RESOLUTION, end, start, (end -start) + 1000000);
	}
}

int main(int argc, char** argv){

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	pthread_mutex_init(&bogus_lock, NULL);

	//set characteristics for motor control
	motor_control.id = 1;
	motor_control.et = 200 * RESOLUTION;
	motor_control.period = 350 * RESOLUTION;
	motor_control.phase = 0;
	motor_control.priority = 3;

	//set characteristics for gyro read
	gyro_read.id = 2;
	gyro_read.et = 50 * RESOLUTION;
	gyro_read.period = 250 * RESOLUTION;
	gyro_read.phase = 0;
	gyro_read.priority = 4;

	//set characteristics for sonic read
	sonic_read.id = 3;
	sonic_read.et = 50 * RESOLUTION;
	sonic_read.period = 100 * RESOLUTION;
	sonic_read.phase = 0;
	sonic_read.priority = 2;

	//set characteristics for gps_read
	gps_read.id = 4;
	gps_read.et = 100 * RESOLUTION;
	gps_read.period = 1000 * RESOLUTION;
	gps_read.phase = 0;
	gps_read.priority = 5;

	//set characteristics for the run time
	runtime_control.id = 5;
	runtime_control.et = 30 * RESOLUTION;
	runtime_control.period = 75 * RESOLUTION;
	runtime_control.phase = 0;
	runtime_control.priority = 1;

	pthread_t  mc_job, gyro_job, sonic_job, gps_job, rt_job, sched, rel_ag;

	//create our jobs
	pthread_create(&mc_job, &attr, (void *) motor_control_task, (void *) &motor_control);
	pthread_create(&gyro_job, &attr, (void *) gyro_task, (void *) &gyro_read);
	pthread_create(&sonic_job, &attr, (void *) sonic_task, (void *) &sonic_read);
	pthread_create(&gps_job, &attr, (void *) gps_task, (void *) &gps_read);
	pthread_create(&rt_job, &attr, (void *) runtime_task, (void *) &rt_job);

	//create scheduling
	pthread_create(&rel_ag, &attr, (void *) release_agent, (void *) NULL);
	pthread_create(&sched, &attr, (void *) scheduler, (void *) NULL);


	pthread_exit(NULL);

	return EXIT_SUCCESS;
}
